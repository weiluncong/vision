// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kinterface_content.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kinterface_5fcontent_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kinterface_5fcontent_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kinterface_5fcontent_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kinterface_5fcontent_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kinterface_5fcontent_2eproto;
class AllInterfaceContent;
struct AllInterfaceContentDefaultTypeInternal;
extern AllInterfaceContentDefaultTypeInternal _AllInterfaceContent_default_instance_;
class AllInterfaceContent_ContentsEntry_DoNotUse;
struct AllInterfaceContent_ContentsEntry_DoNotUseDefaultTypeInternal;
extern AllInterfaceContent_ContentsEntry_DoNotUseDefaultTypeInternal _AllInterfaceContent_ContentsEntry_DoNotUse_default_instance_;
class InterfaceReply;
struct InterfaceReplyDefaultTypeInternal;
extern InterfaceReplyDefaultTypeInternal _InterfaceReply_default_instance_;
class InterfaceRequest;
struct InterfaceRequestDefaultTypeInternal;
extern InterfaceRequestDefaultTypeInternal _InterfaceRequest_default_instance_;
class TaskInterfaceContent;
struct TaskInterfaceContentDefaultTypeInternal;
extern TaskInterfaceContentDefaultTypeInternal _TaskInterfaceContent_default_instance_;
class TaskInterfaceContent_ContentEntry_DoNotUse;
struct TaskInterfaceContent_ContentEntry_DoNotUseDefaultTypeInternal;
extern TaskInterfaceContent_ContentEntry_DoNotUseDefaultTypeInternal _TaskInterfaceContent_ContentEntry_DoNotUse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AllInterfaceContent* Arena::CreateMaybeMessage<::AllInterfaceContent>(Arena*);
template<> ::AllInterfaceContent_ContentsEntry_DoNotUse* Arena::CreateMaybeMessage<::AllInterfaceContent_ContentsEntry_DoNotUse>(Arena*);
template<> ::InterfaceReply* Arena::CreateMaybeMessage<::InterfaceReply>(Arena*);
template<> ::InterfaceRequest* Arena::CreateMaybeMessage<::InterfaceRequest>(Arena*);
template<> ::TaskInterfaceContent* Arena::CreateMaybeMessage<::TaskInterfaceContent>(Arena*);
template<> ::TaskInterfaceContent_ContentEntry_DoNotUse* Arena::CreateMaybeMessage<::TaskInterfaceContent_ContentEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class TaskInterfaceContent_ContentEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskInterfaceContent_ContentEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskInterfaceContent_ContentEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TaskInterfaceContent_ContentEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TaskInterfaceContent_ContentEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TaskInterfaceContent_ContentEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TaskInterfaceContent_ContentEntry_DoNotUse& other);
  static const TaskInterfaceContent_ContentEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TaskInterfaceContent_ContentEntry_DoNotUse*>(&_TaskInterfaceContent_ContentEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "TaskInterfaceContent.ContentEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "TaskInterfaceContent.ContentEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_kinterface_5fcontent_2eproto;
};

// -------------------------------------------------------------------

class TaskInterfaceContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TaskInterfaceContent) */ {
 public:
  inline TaskInterfaceContent() : TaskInterfaceContent(nullptr) {}
  ~TaskInterfaceContent() override;
  explicit PROTOBUF_CONSTEXPR TaskInterfaceContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskInterfaceContent(const TaskInterfaceContent& from);
  TaskInterfaceContent(TaskInterfaceContent&& from) noexcept
    : TaskInterfaceContent() {
    *this = ::std::move(from);
  }

  inline TaskInterfaceContent& operator=(const TaskInterfaceContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskInterfaceContent& operator=(TaskInterfaceContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskInterfaceContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskInterfaceContent* internal_default_instance() {
    return reinterpret_cast<const TaskInterfaceContent*>(
               &_TaskInterfaceContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TaskInterfaceContent& a, TaskInterfaceContent& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskInterfaceContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskInterfaceContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskInterfaceContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskInterfaceContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskInterfaceContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskInterfaceContent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskInterfaceContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TaskInterfaceContent";
  }
  protected:
  explicit TaskInterfaceContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // map<string, string> content = 1;
  int content_size() const;
  private:
  int _internal_content_size() const;
  public:
  void clear_content();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_content() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_content();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      content() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_content();

  // @@protoc_insertion_point(class_scope:TaskInterfaceContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TaskInterfaceContent_ContentEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kinterface_5fcontent_2eproto;
};
// -------------------------------------------------------------------

class AllInterfaceContent_ContentsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AllInterfaceContent_ContentsEntry_DoNotUse, 
    std::string, ::TaskInterfaceContent,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AllInterfaceContent_ContentsEntry_DoNotUse, 
    std::string, ::TaskInterfaceContent,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  AllInterfaceContent_ContentsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR AllInterfaceContent_ContentsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AllInterfaceContent_ContentsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AllInterfaceContent_ContentsEntry_DoNotUse& other);
  static const AllInterfaceContent_ContentsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AllInterfaceContent_ContentsEntry_DoNotUse*>(&_AllInterfaceContent_ContentsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "AllInterfaceContent.ContentsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_kinterface_5fcontent_2eproto;
};

// -------------------------------------------------------------------

class AllInterfaceContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AllInterfaceContent) */ {
 public:
  inline AllInterfaceContent() : AllInterfaceContent(nullptr) {}
  ~AllInterfaceContent() override;
  explicit PROTOBUF_CONSTEXPR AllInterfaceContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllInterfaceContent(const AllInterfaceContent& from);
  AllInterfaceContent(AllInterfaceContent&& from) noexcept
    : AllInterfaceContent() {
    *this = ::std::move(from);
  }

  inline AllInterfaceContent& operator=(const AllInterfaceContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllInterfaceContent& operator=(AllInterfaceContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllInterfaceContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllInterfaceContent* internal_default_instance() {
    return reinterpret_cast<const AllInterfaceContent*>(
               &_AllInterfaceContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AllInterfaceContent& a, AllInterfaceContent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllInterfaceContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllInterfaceContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllInterfaceContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllInterfaceContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllInterfaceContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AllInterfaceContent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllInterfaceContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AllInterfaceContent";
  }
  protected:
  explicit AllInterfaceContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kContentsFieldNumber = 1,
  };
  // map<string, .TaskInterfaceContent> contents = 1;
  int contents_size() const;
  private:
  int _internal_contents_size() const;
  public:
  void clear_contents();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TaskInterfaceContent >&
      _internal_contents() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TaskInterfaceContent >*
      _internal_mutable_contents();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TaskInterfaceContent >&
      contents() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TaskInterfaceContent >*
      mutable_contents();

  // @@protoc_insertion_point(class_scope:AllInterfaceContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AllInterfaceContent_ContentsEntry_DoNotUse,
      std::string, ::TaskInterfaceContent,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> contents_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kinterface_5fcontent_2eproto;
};
// -------------------------------------------------------------------

class InterfaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InterfaceRequest) */ {
 public:
  inline InterfaceRequest() : InterfaceRequest(nullptr) {}
  ~InterfaceRequest() override;
  explicit PROTOBUF_CONSTEXPR InterfaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterfaceRequest(const InterfaceRequest& from);
  InterfaceRequest(InterfaceRequest&& from) noexcept
    : InterfaceRequest() {
    *this = ::std::move(from);
  }

  inline InterfaceRequest& operator=(const InterfaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterfaceRequest& operator=(InterfaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterfaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterfaceRequest* internal_default_instance() {
    return reinterpret_cast<const InterfaceRequest*>(
               &_InterfaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InterfaceRequest& a, InterfaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InterfaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterfaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterfaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterfaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterfaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InterfaceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterfaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InterfaceRequest";
  }
  protected:
  explicit InterfaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskNameFieldNumber = 2,
    kTaskContentFieldNumber = 3,
    kModeFieldNumber = 1,
  };
  // string task_name = 2;
  void clear_task_name();
  const std::string& task_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_name();
  PROTOBUF_NODISCARD std::string* release_task_name();
  void set_allocated_task_name(std::string* task_name);
  private:
  const std::string& _internal_task_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_name(const std::string& value);
  std::string* _internal_mutable_task_name();
  public:

  // .TaskInterfaceContent task_content = 3;
  bool has_task_content() const;
  private:
  bool _internal_has_task_content() const;
  public:
  void clear_task_content();
  const ::TaskInterfaceContent& task_content() const;
  PROTOBUF_NODISCARD ::TaskInterfaceContent* release_task_content();
  ::TaskInterfaceContent* mutable_task_content();
  void set_allocated_task_content(::TaskInterfaceContent* task_content);
  private:
  const ::TaskInterfaceContent& _internal_task_content() const;
  ::TaskInterfaceContent* _internal_mutable_task_content();
  public:
  void unsafe_arena_set_allocated_task_content(
      ::TaskInterfaceContent* task_content);
  ::TaskInterfaceContent* unsafe_arena_release_task_content();

  // int32 mode = 1;
  void clear_mode();
  int32_t mode() const;
  void set_mode(int32_t value);
  private:
  int32_t _internal_mode() const;
  void _internal_set_mode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:InterfaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_name_;
  ::TaskInterfaceContent* task_content_;
  int32_t mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kinterface_5fcontent_2eproto;
};
// -------------------------------------------------------------------

class InterfaceReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InterfaceReply) */ {
 public:
  inline InterfaceReply() : InterfaceReply(nullptr) {}
  ~InterfaceReply() override;
  explicit PROTOBUF_CONSTEXPR InterfaceReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterfaceReply(const InterfaceReply& from);
  InterfaceReply(InterfaceReply&& from) noexcept
    : InterfaceReply() {
    *this = ::std::move(from);
  }

  inline InterfaceReply& operator=(const InterfaceReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterfaceReply& operator=(InterfaceReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterfaceReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterfaceReply* internal_default_instance() {
    return reinterpret_cast<const InterfaceReply*>(
               &_InterfaceReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InterfaceReply& a, InterfaceReply& b) {
    a.Swap(&b);
  }
  inline void Swap(InterfaceReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterfaceReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterfaceReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterfaceReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterfaceReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InterfaceReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterfaceReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InterfaceReply";
  }
  protected:
  explicit InterfaceReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorInfoFieldNumber = 3,
    kAllContentFieldNumber = 2,
    kResFieldNumber = 1,
  };
  // string error_info = 3;
  void clear_error_info();
  const std::string& error_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_info();
  PROTOBUF_NODISCARD std::string* release_error_info();
  void set_allocated_error_info(std::string* error_info);
  private:
  const std::string& _internal_error_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_info(const std::string& value);
  std::string* _internal_mutable_error_info();
  public:

  // .AllInterfaceContent all_content = 2;
  bool has_all_content() const;
  private:
  bool _internal_has_all_content() const;
  public:
  void clear_all_content();
  const ::AllInterfaceContent& all_content() const;
  PROTOBUF_NODISCARD ::AllInterfaceContent* release_all_content();
  ::AllInterfaceContent* mutable_all_content();
  void set_allocated_all_content(::AllInterfaceContent* all_content);
  private:
  const ::AllInterfaceContent& _internal_all_content() const;
  ::AllInterfaceContent* _internal_mutable_all_content();
  public:
  void unsafe_arena_set_allocated_all_content(
      ::AllInterfaceContent* all_content);
  ::AllInterfaceContent* unsafe_arena_release_all_content();

  // bool res = 1;
  void clear_res();
  bool res() const;
  void set_res(bool value);
  private:
  bool _internal_res() const;
  void _internal_set_res(bool value);
  public:

  // @@protoc_insertion_point(class_scope:InterfaceReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_info_;
  ::AllInterfaceContent* all_content_;
  bool res_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kinterface_5fcontent_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TaskInterfaceContent

// map<string, string> content = 1;
inline int TaskInterfaceContent::_internal_content_size() const {
  return content_.size();
}
inline int TaskInterfaceContent::content_size() const {
  return _internal_content_size();
}
inline void TaskInterfaceContent::clear_content() {
  content_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TaskInterfaceContent::_internal_content() const {
  return content_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TaskInterfaceContent::content() const {
  // @@protoc_insertion_point(field_map:TaskInterfaceContent.content)
  return _internal_content();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TaskInterfaceContent::_internal_mutable_content() {
  return content_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TaskInterfaceContent::mutable_content() {
  // @@protoc_insertion_point(field_mutable_map:TaskInterfaceContent.content)
  return _internal_mutable_content();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AllInterfaceContent

// map<string, .TaskInterfaceContent> contents = 1;
inline int AllInterfaceContent::_internal_contents_size() const {
  return contents_.size();
}
inline int AllInterfaceContent::contents_size() const {
  return _internal_contents_size();
}
inline void AllInterfaceContent::clear_contents() {
  contents_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TaskInterfaceContent >&
AllInterfaceContent::_internal_contents() const {
  return contents_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TaskInterfaceContent >&
AllInterfaceContent::contents() const {
  // @@protoc_insertion_point(field_map:AllInterfaceContent.contents)
  return _internal_contents();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TaskInterfaceContent >*
AllInterfaceContent::_internal_mutable_contents() {
  return contents_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TaskInterfaceContent >*
AllInterfaceContent::mutable_contents() {
  // @@protoc_insertion_point(field_mutable_map:AllInterfaceContent.contents)
  return _internal_mutable_contents();
}

// -------------------------------------------------------------------

// InterfaceRequest

// int32 mode = 1;
inline void InterfaceRequest::clear_mode() {
  mode_ = 0;
}
inline int32_t InterfaceRequest::_internal_mode() const {
  return mode_;
}
inline int32_t InterfaceRequest::mode() const {
  // @@protoc_insertion_point(field_get:InterfaceRequest.mode)
  return _internal_mode();
}
inline void InterfaceRequest::_internal_set_mode(int32_t value) {
  
  mode_ = value;
}
inline void InterfaceRequest::set_mode(int32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:InterfaceRequest.mode)
}

// string task_name = 2;
inline void InterfaceRequest::clear_task_name() {
  task_name_.ClearToEmpty();
}
inline const std::string& InterfaceRequest::task_name() const {
  // @@protoc_insertion_point(field_get:InterfaceRequest.task_name)
  return _internal_task_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InterfaceRequest::set_task_name(ArgT0&& arg0, ArgT... args) {
 
 task_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InterfaceRequest.task_name)
}
inline std::string* InterfaceRequest::mutable_task_name() {
  std::string* _s = _internal_mutable_task_name();
  // @@protoc_insertion_point(field_mutable:InterfaceRequest.task_name)
  return _s;
}
inline const std::string& InterfaceRequest::_internal_task_name() const {
  return task_name_.Get();
}
inline void InterfaceRequest::_internal_set_task_name(const std::string& value) {
  
  task_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InterfaceRequest::_internal_mutable_task_name() {
  
  return task_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InterfaceRequest::release_task_name() {
  // @@protoc_insertion_point(field_release:InterfaceRequest.task_name)
  return task_name_.Release();
}
inline void InterfaceRequest::set_allocated_task_name(std::string* task_name) {
  if (task_name != nullptr) {
    
  } else {
    
  }
  task_name_.SetAllocated(task_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (task_name_.IsDefault()) {
    task_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InterfaceRequest.task_name)
}

// .TaskInterfaceContent task_content = 3;
inline bool InterfaceRequest::_internal_has_task_content() const {
  return this != internal_default_instance() && task_content_ != nullptr;
}
inline bool InterfaceRequest::has_task_content() const {
  return _internal_has_task_content();
}
inline void InterfaceRequest::clear_task_content() {
  if (GetArenaForAllocation() == nullptr && task_content_ != nullptr) {
    delete task_content_;
  }
  task_content_ = nullptr;
}
inline const ::TaskInterfaceContent& InterfaceRequest::_internal_task_content() const {
  const ::TaskInterfaceContent* p = task_content_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskInterfaceContent&>(
      ::_TaskInterfaceContent_default_instance_);
}
inline const ::TaskInterfaceContent& InterfaceRequest::task_content() const {
  // @@protoc_insertion_point(field_get:InterfaceRequest.task_content)
  return _internal_task_content();
}
inline void InterfaceRequest::unsafe_arena_set_allocated_task_content(
    ::TaskInterfaceContent* task_content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_content_);
  }
  task_content_ = task_content;
  if (task_content) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InterfaceRequest.task_content)
}
inline ::TaskInterfaceContent* InterfaceRequest::release_task_content() {
  
  ::TaskInterfaceContent* temp = task_content_;
  task_content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskInterfaceContent* InterfaceRequest::unsafe_arena_release_task_content() {
  // @@protoc_insertion_point(field_release:InterfaceRequest.task_content)
  
  ::TaskInterfaceContent* temp = task_content_;
  task_content_ = nullptr;
  return temp;
}
inline ::TaskInterfaceContent* InterfaceRequest::_internal_mutable_task_content() {
  
  if (task_content_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskInterfaceContent>(GetArenaForAllocation());
    task_content_ = p;
  }
  return task_content_;
}
inline ::TaskInterfaceContent* InterfaceRequest::mutable_task_content() {
  ::TaskInterfaceContent* _msg = _internal_mutable_task_content();
  // @@protoc_insertion_point(field_mutable:InterfaceRequest.task_content)
  return _msg;
}
inline void InterfaceRequest::set_allocated_task_content(::TaskInterfaceContent* task_content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_content_;
  }
  if (task_content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(task_content);
    if (message_arena != submessage_arena) {
      task_content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_content, submessage_arena);
    }
    
  } else {
    
  }
  task_content_ = task_content;
  // @@protoc_insertion_point(field_set_allocated:InterfaceRequest.task_content)
}

// -------------------------------------------------------------------

// InterfaceReply

// bool res = 1;
inline void InterfaceReply::clear_res() {
  res_ = false;
}
inline bool InterfaceReply::_internal_res() const {
  return res_;
}
inline bool InterfaceReply::res() const {
  // @@protoc_insertion_point(field_get:InterfaceReply.res)
  return _internal_res();
}
inline void InterfaceReply::_internal_set_res(bool value) {
  
  res_ = value;
}
inline void InterfaceReply::set_res(bool value) {
  _internal_set_res(value);
  // @@protoc_insertion_point(field_set:InterfaceReply.res)
}

// .AllInterfaceContent all_content = 2;
inline bool InterfaceReply::_internal_has_all_content() const {
  return this != internal_default_instance() && all_content_ != nullptr;
}
inline bool InterfaceReply::has_all_content() const {
  return _internal_has_all_content();
}
inline void InterfaceReply::clear_all_content() {
  if (GetArenaForAllocation() == nullptr && all_content_ != nullptr) {
    delete all_content_;
  }
  all_content_ = nullptr;
}
inline const ::AllInterfaceContent& InterfaceReply::_internal_all_content() const {
  const ::AllInterfaceContent* p = all_content_;
  return p != nullptr ? *p : reinterpret_cast<const ::AllInterfaceContent&>(
      ::_AllInterfaceContent_default_instance_);
}
inline const ::AllInterfaceContent& InterfaceReply::all_content() const {
  // @@protoc_insertion_point(field_get:InterfaceReply.all_content)
  return _internal_all_content();
}
inline void InterfaceReply::unsafe_arena_set_allocated_all_content(
    ::AllInterfaceContent* all_content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(all_content_);
  }
  all_content_ = all_content;
  if (all_content) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InterfaceReply.all_content)
}
inline ::AllInterfaceContent* InterfaceReply::release_all_content() {
  
  ::AllInterfaceContent* temp = all_content_;
  all_content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AllInterfaceContent* InterfaceReply::unsafe_arena_release_all_content() {
  // @@protoc_insertion_point(field_release:InterfaceReply.all_content)
  
  ::AllInterfaceContent* temp = all_content_;
  all_content_ = nullptr;
  return temp;
}
inline ::AllInterfaceContent* InterfaceReply::_internal_mutable_all_content() {
  
  if (all_content_ == nullptr) {
    auto* p = CreateMaybeMessage<::AllInterfaceContent>(GetArenaForAllocation());
    all_content_ = p;
  }
  return all_content_;
}
inline ::AllInterfaceContent* InterfaceReply::mutable_all_content() {
  ::AllInterfaceContent* _msg = _internal_mutable_all_content();
  // @@protoc_insertion_point(field_mutable:InterfaceReply.all_content)
  return _msg;
}
inline void InterfaceReply::set_allocated_all_content(::AllInterfaceContent* all_content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete all_content_;
  }
  if (all_content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(all_content);
    if (message_arena != submessage_arena) {
      all_content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, all_content, submessage_arena);
    }
    
  } else {
    
  }
  all_content_ = all_content;
  // @@protoc_insertion_point(field_set_allocated:InterfaceReply.all_content)
}

// string error_info = 3;
inline void InterfaceReply::clear_error_info() {
  error_info_.ClearToEmpty();
}
inline const std::string& InterfaceReply::error_info() const {
  // @@protoc_insertion_point(field_get:InterfaceReply.error_info)
  return _internal_error_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InterfaceReply::set_error_info(ArgT0&& arg0, ArgT... args) {
 
 error_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InterfaceReply.error_info)
}
inline std::string* InterfaceReply::mutable_error_info() {
  std::string* _s = _internal_mutable_error_info();
  // @@protoc_insertion_point(field_mutable:InterfaceReply.error_info)
  return _s;
}
inline const std::string& InterfaceReply::_internal_error_info() const {
  return error_info_.Get();
}
inline void InterfaceReply::_internal_set_error_info(const std::string& value) {
  
  error_info_.Set(value, GetArenaForAllocation());
}
inline std::string* InterfaceReply::_internal_mutable_error_info() {
  
  return error_info_.Mutable(GetArenaForAllocation());
}
inline std::string* InterfaceReply::release_error_info() {
  // @@protoc_insertion_point(field_release:InterfaceReply.error_info)
  return error_info_.Release();
}
inline void InterfaceReply::set_allocated_error_info(std::string* error_info) {
  if (error_info != nullptr) {
    
  } else {
    
  }
  error_info_.SetAllocated(error_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_info_.IsDefault()) {
    error_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InterfaceReply.error_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kinterface_5fcontent_2eproto
